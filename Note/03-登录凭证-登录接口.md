# 一、用户登录接口

## 1.服务器设置 cookie

在 Node 项目中，使用 koa 框架，为客户端（浏览器）设置 cookie。并设置过期时间。

Demo\02-服务器cookie设置.js

```js
const Koa = require('koa')
const KoaRouter = require('@koa/router')

// 创建 Koa 服务器
const app = new Koa()

// 创建路由对象
const userRouter = new KoaRouter({ prefix: '/users' })

// 在路由中，注册中间件
userRouter.get('/login', (ctx, next) => {
  // 在服务器中，为浏览器设置 cookie
  ctx.cookies.set('slogan', 'Never Mind the Scandal and Libel', {
    maxAge: 60 * 1000 * 5
  })

  ctx.body = '登录成功~'
})

userRouter.get('/list', (ctx, next) => {
  // 验证用户的登录凭证，即 cookie
  const value = ctx.cookies.get('slogan')
  console.log('value:', value)

  if (value === 'Never Mind the Scandal and Libel') {
    ctx.body = 'user list data~'
  } else {
    ctx.body = '没有权限访问用户列表，请先登录~'
  }
})

// 注册路由
app.use(userRouter.routes())
app.use(userRouter.allowedMethods())

// 开启 Koa 服务器
app.listen(9000, () => {
  console.log('koa 服务器启动成功~')
})
```

服务器设置 cookie 后，浏览器发送请求时，自动携带，前端不需要做任何操作。

总结：cookie 进行身份验证的步骤：

1. 服务器设置 cookie
2. 客户端（浏览器）获取服务器设置的 cookie，并保存在本地。
3. 在同一个作用域下，进行访问（域名/路径），会自动携带 cookie。
4. 服务器可以通过客户端携带的 cookie，验证用户的身份。

## 2.服务器设置 session

明文的 cookie，容易被伪造。

需要用到 session，它基于 cookie，做了加密的操作。

安装 *koa-session* 库。

```shell
npm install koa-session
```

不“加盐”，仅会进行一次加密，容易伪造。

Demo\03-服务器session设置.js

```js
const session = koaSession({
  key: 'sessionid',
  signed: false,
  maxAge: 60 * 1000 * 5,
}, app)
app.use(session)
```

| name      | value                                                        | ...  |
| --------- | ------------------------------------------------------------ | ---- |
| sessionid | eyJzbG9nYW4iOiJOZXZlciBNaW5kIHRoZSBTY2FuZGFsIGFuZCBMaWJlbCIsIl9leHBpcmUiOjE2ODI3ODM1NjM5NzYsIl9tYXhBZ2UiOjMwMDAwMH0= | ...  |

“加盐”操作。生成两个 cookie，进行双重认证，客户端不好伪造，因为不知道服务器加的盐。

Demo\03-服务器session设置.js

```js
const Koa = require('koa')
const KoaRouter = require('@koa/router')
const koaSession = require('koa-session')

// 创建 Koa 服务器
const app = new Koa()

// 创建路由对象
const userRouter = new KoaRouter({ prefix: '/users' })

const session = koaSession({
  key: 'sessionid',
  signed: true,
  maxAge: 60 * 1000 * 5,
}, app)
app.keys = ['aaa', 'bbb', 'zzt', 'kobe']
app.use(session)

// 在路由中，注册中间件
userRouter.get('/login', (ctx, next) => {
  ctx.session.slogan = 'Never Mind the Scandal and Libel'

  ctx.body = '登录成功~'
})

userRouter.get('/list', (ctx, next) => {
  // 验证用户的登录凭证，即 cookie
  const value = ctx.session.slogan
  console.log('value:', value)

  if (value === 'Never Mind the Scandal and Libel') {
    ctx.body = 'user list data~'
  } else {
    ctx.body = '没有权限访问用户列表，请先登录~'
  }
})

// 注册路由
app.use(userRouter.routes())
app.use(userRouter.allowedMethods())


// 开启 Koa 服务器
app.listen(9000, () => {
  console.log('koa 服务器启动成功~')
})
```

| name          | value                                                        | ...  |
| ------------- | ------------------------------------------------------------ | ---- |
| sessionid.sig | zabSQNk7eUGFTNXvSaSKL_e3ZO0                                  | ...  |
| sessionid     | eyJzbG9nYW4iOiJOZXZlciBNaW5kIHRoZSBTY2FuZGFsIGFuZCBMaWJlbCIsIl9leHBpcmUiOjE2ODI4MjIxNTY0MTMsIl9tYXhBZ2UiOjMwMDAwMH0= |      |

## 3.cookie、session 缺点。

Cookie 会被附加在每个 HTTP 请求中，所以无形中，增加了流量（事实上某些请求是不需要的）；

Cookie 是明文传递的，所以存在安全性的问题；

Cookie 的大小限制是 4KB，对于复杂的需求来说，是不够的；

最主要的两个原因：

对于浏览器外的其他客户端（比如 iOS、Android），必须手动的设置 cookie 和 session；

对于分布式系统，和服务器集群来说，在不同的系统之间，正确的解析 session，是比较麻烦的。

> 分布式系统，将一个系统，按功能模块分为若干个系统。

## 4.token 是什么？

目前，前后端分离的项目中，使用 token 来进行身份验证的是最多的情况：

token 可以翻译为令牌；也就是在验证了用户账号和密码正确的情况，给用户颁发一个令牌；

这个令牌作为后续用户访问一些接口或者资源的凭证；

我们可以根据这个凭证来判断用户是否有权限来访问；

token 的使用应该分成两个重要的步骤：
- 生成 token：用户在登录时，颁发 token；
- 验证 token：用户在访问某些资源或者接口时，验证 token；

## 5.JWT 实现 token

**JWT 指 json web token**；生成的 token 由三部分组成：

header
- `alg`：采用的加密算法，默认是 *HMAC SHA256（HS256）*，采用**同一个密钥**进行加密和解密；
- `typ`：JWT，固定值，通常都写成 JWT 即可；
- 会通过 *base64Url* 算法进行编码；

payload
- 携带的数据，比如可将用户的 `id` 和 `name` 放到 payload 中；
- 默认也会携带 `iat（issued at）`，令牌的签发时间；
- 也可设置过期时间：`exp（expiration time`）；
- 会通过 *base64Url* 算法进行编码

signature
- 设置一个 `secretKey`（默认对称加密），将前两部分的结果合并后，进行 *HMAC SHA256（HS256）*的算法；
  - `HMACSHA256(base64Url(header)+.+base64Url(payload), secretKey);`
- 一旦 `secretKey` 暴露出去，就可以伪造颁发 token，也可以解密 token；是一件非常危险的事。

<img src="NodeAssets/JWT.jpg" alt="JWT" style="zoom:80%;" />

> header、payload 部分，可以被逆向解密出来。
>
> 防止 token 被伪造，最重要的是 signature 部分。
>
> 在对称加密中，secretkey 一定要保管好，一旦泄露，就能伪造 token 了。

### 1.对称加密

对称加密，加密解密，都是一个密钥，即 `secretKey`。

安装一个库 *jsonwebtoken*

```shell
npm install jsonwebtoken
```

使用对称加密，生成一个 token。

> 在客户端，一般通过 *Bearer token* 的形式，在请求的 `header` 中携带 token。

服务器拿到 token 后：

1. 验证有效性。

2. 验证 token 里的用户信息。

验证不通过，会抛出异常，使用 `try...catch` 包裹验证的过程。

Demo\04-对称加密token颁发和验证.js

```js
const Koa = require('koa')
const KoaRouter = require('@koa/router')
const jwt = require('jsonwebtoken')

// 创建 Koa 服务器
const app = new Koa()

// 创建路由对象
const userRouter = new KoaRouter({ prefix: '/users' })

const secretKey = 'aaabbbcccxxx'

// 在路由中，注册中间件
userRouter.get('/login', (ctx, next) => {
  // 1.颁发 token
  const payload = { id: 111, name: 'zzt' }
  const token = jwt.sign(payload, secretKey, {
    expiresIn: 60 // 单位：秒
  })

  ctx.body = {
    code: 0,
    token,
    msg: '登录成功~'
  }
})

userRouter.get('/list', (ctx, next) => {
  // 1.获取客户端携带过来的 token
  const authorization = ctx.headers.authorization
  const token = authorization.replace('Bearer ', '')
  console.log('token:', token)

  // 2.验证 token
  try {
    const result = jwt.verify(token, secretKey)
    console.log('result:', result)
    // result: { id: 111, name: 'zzt', iat: 1682824424, exp: 1682824484 }

    ctx.body = {
      code: 0,
      data: [
        { id: 111, name: 'zzt' },
        { id: 112, name: 'kobe' },
        { id: 113, name: 'lilei' }
      ]
    }
  } catch (err) {
    console.log('err:', err)
    ctx.body = {
      code: -1010,
      msg: 'token 过期或者无效~'
    }
  }

})

// 注册路由
app.use(userRouter.routes())
app.use(userRouter.allowedMethods())


// 开启 Koa 服务器
app.listen(9000, () => {
  console.log('koa 服务器启动成功~')
})
```

### 2.非对称加密

前面说过，*HS256* 加密算法，一旦密钥（secretKey）暴露，是非常危险的：

那么拿到这个密钥后，这个子系统，既可以发布令牌，也可以验证令牌；

然而，在分布式系统中：

- 每一个子系统，又都需要获取到密钥，才能验证用户信息；
- 事实上，对于一些资源服务器来说，它们只需要有验证令牌的能力就可以了，只有用户登录的系统，才需要有颁发令牌的的能力；

这个时候，我们可以使用非对称加密，*RS256* 算法，它需要用到：
- 私钥（private key）：用于颁发令牌；
- 公钥（public key）：用于验证令牌；

此时只要保证，存储私钥服务器的安全性，那么就是相对安全的。

在分布式架构中，

- 用户系统中，使用私钥颁发令牌，
- 在商品系统，订单系统等等，其它资源系统上，用公钥验证令牌即可。

使用 *openssl* 来生成一对私钥、公钥：

- 先生成私钥，再利用私钥生成公钥。

> Mac 直接使用 terminal 终端即可；
>
> Windows 默认的 cmd 终端是不能直接使用的，建议直接使用 git bash 终端；

```shell
openssl
OpenSSL> genrsa -out private.key 2048
OpenSSL> rsa -in private.key -pubout -out public.key
```

使用 jwt 加密、解密时，传入算法。

> 【注意】：对称加密用的是 HS256 算法，非对称加密要用 RS256 算法

Demo\05-非对称加密token颁发和验证.js

```js
const fs = require('fs')
const Koa = require('koa')
const KoaRouter = require('@koa/router')
const jwt = require('jsonwebtoken')

// 创建 Koa 服务器
const app = new Koa()

// 创建路由对象
const userRouter = new KoaRouter({ prefix: '/users' })

// 读取公钥和私钥
const privateKey = fs.readFileSync('./keys/private.key')
const publicKey = fs.readFileSync('./keys/public.key')

// 在路由中，注册中间件
userRouter.get('/login', (ctx, next) => {
  // 1.颁发 token
  const payload = { id: 111, name: 'zzt' }
  // jwt.sign 支持传 buffer 类型
  const token = jwt.sign(payload, privateKey, {
    expiresIn: 60,
    algorithm: 'RS256'
  })

  ctx.body = {
    code: 0,
    token,
    msg: '登陆成功~'
  }
})

userRouter.get('/list', (ctx, next) => {
  // 1.获取客户端的 token
  const authorization = ctx.header.authorization
  const token = authorization.replace('Bearer ', '')
  console.log('token:', token)

  // 2.验证 token
  try {
    const result = jwt.verify(token, publicKey, {
      algorithms: ['RS256']
    })
    console.log('result:', result)

    ctx.body = {
      code: 0,
      data: [
        { id: 111, name: 'zzt' },
        { id: 112, name: 'kobe' },
        { id: 113, name: 'messi' },
      ]
    }
  } catch (err) {
    console.log('err:', err)
    ctx.body = {
      code: -1010,
      msg: 'token 过期或无效~'
    }
  }
})

// 注册路由
app.use(userRouter.routes())
app.use(userRouter.allowedMethods())


// 开启 Koa 服务器
app.listen(9000, () => {
  console.log('koa 服务器启动成功~')
})
```

## 6.在项目中实现

> 为 koaRouter 生成一个代码片段
>
> C:\Users\Zetian Zhu\AppData\Roaming\Code\User\snippets\javascript.json
>
> ```json
> {
> 	"koa Router": {
> 		"prefix": "koa-router",
> 		"body": [
> 			"const KoaRouter = require('@koa/router')",
> 			"",
> 			"const ${1:home}Router = new KoaRouter({ prefix: '/${1:home}' })",
> 			"",
> 			"module.exports = ${1:home}Router"
> 		],
> 		"description": "koaRouter"
> 	}
> }
> ```

在项目中，编写 login.router.js，在其中编写登录的服务。

src\router\login.router.js

```js
const KoaRouter = require('@koa/router')
const { login, test } = require('../controller/login.controller');
const { verifyLogin, verifyAuth } = require('../middleware/login.middleware')

const loginRouter = new KoaRouter({ prefix: '/login' })

loginRouter.post('/', verifyLogin, login)
loginRouter.get('/test-auth', verifyAuth, test)

module.exports = loginRouter
```

src\middleware\login.middleware.js

```js
const {
  NAME_OR_PASSWORD_IS_REQUIRED,
  NAME_IS_NOT_EXIST,
  PASSWORD_IS_INCORRENT,
  UNAUTHORIZATION,
  INVALID_AUTHORIZATION
} = require('../config/error')
const userService = require('../service/user.service')
const md5password = require('../utils/md5-password')
const { PUBLIC_KEY } = require('../config/secret')
const jwt = require('jsonwebtoken')

/**
 * @description: 此中间件用于：验证用户登录时的用户名和密码
 * @Author: ZeT1an
 * @param {*} ctx koa ctx
 * @param {*} next koa next
 * @return {*}
 */
const verifyLogin = async (ctx, next) => {
  const { name, password } = ctx.request.body

  // 1.判断用户名、密码是否为空
  if (!name || !password) {
    return ctx.app.emit('error', NAME_OR_PASSWORD_IS_REQUIRED, ctx)
  }

  // 2.查询该用户是否在数据库中存在
  const users = await userService.findUserByName(name)
  const user = users[0]
  if (!user) {
    return ctx.app.emit('error', NAME_IS_NOT_EXIST, ctx)
  }

  // 3.查询数据库中，密码和用户传递的密码，是否一直
  if (user.password !== md5password(password)) {
    return ctx.app.emit('error', PASSWORD_IS_INCORRENT, ctx)
  }

  // 4.将 user 对象，保存在 ctx 中
  ctx.user = user

  next()
}

/**
 * @description: 此中间件用于：验证请求的授权（token 令牌）
 * @Author: ZeT1an
 * @param {*} ctx koa ctx
 * @param {*} next koa next
 * @return {*}
 */
const verifyAuth = async (ctx, next) => {
  // 1.获取 token
  const authorization = ctx.headers.authorization
  if (!authorization) {
    return ctx.app.emit('error', UNAUTHORIZATION, ctx)
  }

  const token = authorization.replace('Bearer ', '')

  // 2.验证 token 是否是有效的
  try {
    const result = jwt.verify(token, PUBLIC_KEY, {
      algorithms: ['RS256']
    })

    // 3.将 user 对象，保存在 ctx 中
    ctx.user = result

    next()
  } catch (err) {
    ctx.app.emit('error', INVALID_AUTHORIZATION, ctx)
  }
}

module.exports = {
  verifyLogin,
  verifyAuth
}
```

> 【注意】：`fs.readFileSync(path)`中，`path` 是相对路径，相对于项目启动目录，也就是根目录。
>
> 除非用绝对路径 `path.resolve(__dirname, 'xxxx')`

src\config\secret.js

```js
const fs = require('fs')
const path = require('path')

const PRIVATE_KEY = fs.readFileSync(path.resolve(__dirname, './keys/private.key'))
const PUBLIC_KEY = fs.readFileSync(path.resolve(__dirname, './keys/public.key'))

module.exports = {
  PRIVATE_KEY,
  PUBLIC_KEY
}
```

